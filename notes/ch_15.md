# Practical Malware Analysis Notes

## Ch. 15 Anti-Disassembly

__*Any code that executes successfully can be reverse-engineered...*__ 

### Introduction

- Anti-disassembly techniques can be crafted manually, by a tool during build and deployment, or interwoven into malware source code.
- Anti-disassembly is used by bad-actors to delay/prevent analysis of malicious software. 
- Any software that can execute can be reverse-engineered; anti-disassembly only increases the skill and time required to do so.

### Understanding Anti-Disassembly

- Executable code can have multiple representations in disassembly, some of which can be different than the actual functionality of the code during execution.
- Anti-disassembly techniques take advantage of assumptions/limitations of disassemblers.
- Disassemblers can only represent each byte of a program as part of one instruction at a time.
- Trick the disassembler into disassembling at a wrong address and a valid instruction can be hidden.
- Anti-disassembly techniques can be generic and try to confuse most disassemblers, other techniques target specific disassemblers or algorithms.

### Defeating Disassembly Algorithms

* Disassemblers must make assumptions.
* Linear-disassembly:
    - Is commonly used in debuggers and basic disassemblers.
    - The size of the disassembled instruction is used to calculate the next byte to disassemble.
    - Disregards all program control-flow
    - Drawback is that it will disassemble too much code because it disassembles until the end of the code section.
    - Data in the code section will cause problems such as pointer values and jump tables.
* Flow-Oriented Disassembly:
    - More advanced algorithm used by most commercial disassemblers such as IDA Pro.
    - Does not assume that all data is instructions. 
    - When an unconditional jump instruction is encountered, the target address is saved to be disassembled at a later time and the disassembly starts back at a previously saved address.
    - When a conditional jump instruction is encountered, the target address is saved to be disassembled at a later time while the disassembly continues sequentially.
    - Flow-Oriented disassemblers can correctly disassemble code when the correct instructions follow an unconditional jump. While the linear disassembler would continue to sequentially disassemble the code after the unconditional branch instruction and possibly incorrectly disassemble the instructions or data.
    - Most flow-oriented disassemblers will first process the false branch of conditional branch instructions and thus will trust that branch more when the disassembly is different for each branch on the same block of code.
    - Call instructions are handled similarly to conditional jump instructions.
    - Call instructions can be used to hide pointers to data. Data can be placed after the call instruction, then following the data is the pop and ret instructions. The call instruction does not call a function and is only used to place the data on the stack as if it was the functions return address. The pop instruction pops the data off the stack into a register.
    

### Anti-Disassembly Techniques

* Introduction
    - Malicious code tricks disassemblers by taking advantage of the assumptions that disassemblers make.
    - Advanced methods take advantage of information the disassembler doesn't have access to as well as generating obfuscated code.
* Jump Instructions with the Same Target
    - Most common technique.
    - Two back to back conditional branch instructions which have the same target address. The two branch instructions will be evaluated with opposite conditions. Therefore, the two conditional branch instructions function as one unconditional branch instruction.
    - This can cause the disassembler to follow a branch that will never be taken and effectively hide the instructions that will actually execute.
    - Uses a rogue byte.
* A Jump Instruction with a Constant Condition
    - Using a conditional branch instruction in a location where the condition will always be constant. 
    - The instruction "xor eax, eax" is commonly used to satisfy the constant condition of setting the zero flag. 
    - This technique again takes advantage of the disassembler processing the false branch before the true branch.
    - Uses a rogue byte.
* Impossible Disassembly 
    - The goal of impossible disassembly is to create a rogue byte that cannot be ignored by the disassembler.
    - One method is to have a jump instruction where the target address is in the middle of another valid instruction. (Inward-pointing jmp instruction)
    - The first example below essentially becomes a "NOP". eax++; eax--;
    ```  
        EX:  jmp  -1
             EB   FF   C0   48
                 inc  eax  dec eax

        EX: 66  B8  EB  05  31  C0  74  F9  E8
            Disassembly             Execution
            * mov ax, 05EBh         mov ax, 05EBh
            * xor eax, eax          xor eax, eax
            * jz -7                 jz -7
            * Call                  jmp 5
                                    real code...
    ```
* NOP-ing Out Instructions with IDA Pro
    - NOP-out instructions using IDA Python.
    ```
          import idaapi
          idaapi.CompileLine('static n_key(){RunPythonStatement("nopIt()"); }')
          AddHotkey("Alt-N", "n_key")
          def nopIt():
            start = ScreenEA()
            end = NextHead(start)
            for ea in range(start, end):
              PatchByte(ea, 0x90)
            Jump(end)
            Refresh()
    ```

### Obscuring Flow Control

* Introduction
    - IDA Pro correlates function calls and deduces high level information based on how functions are related to each other.
    - Malware authors can easily bypass this by using non standard programming styles and compilers.
* The Function Pointer Problem
    -  Function pointers, even when used correctly, reduce the amount of information that can be automatically deduced about the flow of the program.
    -  Function pointers created in non standard ways tend to require dynamic analysis to reverse engineer.
    -  During a function, the instruction "mov \[ebp+var\], offset sub_addr" places the address of another function on the stack. Later in the function, the second function can be called by using "call \[ebp+var\]". Using this method IDA will only find one xref to the second function no matter how many times the function is actually called. 
    -  Function prototype information is also lost.
* Adding Missing Code Cross-References in IDA Pro
    - When the function information is not automatically added by IDA we can manually add it using the IDC function call AddCodeXref.
    - AddCodeXref: takes in 3 arguments. 
        + Location the reference is from.
        + Location the reference is to.
        + Flow type (call, jump...)
* Return Pointer Abuse
    - The return instruction (ret or retn) is also used to transfer control in a program.
    - A call instruction acts as a jump instruction but it also pushes a return pointer onto the stack.
    - The return address is the memory location immediately following the call instruction.
    - The return instruction is the opposite of the call instruction, therefore it is a combination of pop and jump. First popping the return address off of the stack then jumping to it.
    - There is no reason the return instruction can't be used as general control throughout the program though.
    - This technique prevents disassemblers from showing cross references and causes the disassembly to stop prematurely.
* Misusing Structured Exception Handlers
    - SEH mechanisms can be used to create control flow that cannot be followed by modern disassemblers.
    - Exceptions can be triggered by many different conditions such as accessing invalid memory regions, dividing by zero, or by calling the RaiseExecption function.
    - SEH is a sequence of functions used to handle exceptions in a thread. If one function can not handle the exception it passes the exception to the next function.
    - To locate the SEH chain, the operating system looks at the FS segment register. The FS segment register contains the segment to access the TEB. The first structure in the TEB is the TIB. The first bytes of the TIB are the address of the SEH Chain.
    - The first element in the EXCEPTION_REGISTRATION record points to the previous record and the second field points to the handler function.
    - To manipulate control flow we need to add our own handler at the top of the list.
    - A record is two DWORDs so we use two push instructions to add our record to the list. The first push is the pointer to the handler function and the second push is the pointer to the next record. 
    - The assembly to add an execption handler is below:
        ```
        push ExceptionHandler
        push fs:[0]
        mov fs:[0], esp
        ```
    - Software DEP is a problem for this obfuscation method. Handwritten assembly can get around this by using assemblers that support SafeSEH directives. Such as using a Microsoft C compiler and the /SAFESEh:NO linker command.
    - When the exception handler executes, the stack will be changed drastically. This is because an extra SEH is added by the OS so we must unlink both. To clean up the stack we use the following instructions.
        ```
        mov esp, [esp+8]
        mov eax, fs:[0]
        mov eax, [eax]
        mov eax, [eax]
        mov fs:[0], eax
        add esp, 8
        ```
    - Using this method to obstruct control flow will cause the malicious function to have no references. 

### Thwarting Stack-Frame Analysis

- Algorithms must make assumptions to recreate the stack frame.
- Thwarting Stack-Frame analysis will also hinder tools such as decompilers. 
- Stack frame analysis is dependent on the use of compilers, so handwritten assembly can be written to defeat this analysis. 
- A function can have an ESP based stack instead of a EBP based stack. 
- By using a comparison with the value in ESP the disassembler will have to make a choice of what value to use for ESP but it will choose incorrectly. 
- If the false branch uses an instruction such as "add esp, 104h" the stack will be set up very incorrectly.

### Conclusion

- Anti-disassembly is a class of techniques that take advantage of the difficulties of analysis.

### Other
- call $+5 : Calls the location immediately following itself.
- Hide address by adding to hex values, such as 400000h + 1486h. This avoids the address reference.


### Definitions:

- Anti-disassembly: Specially crafted code or data create incorrect program disassembly listings.
- Linear-disassembly: Iterates over a block of code disassembling one instruction at a time linearly without deviation.
- Flow-oriented-disassembly: Does not blindly iterate assuming all data is code. Examines each instruction and builds a list of target locations to disassemble. Gives consideration to control flow.
- Impossible disassembly: instructions that will not be accurately represented by any traditional assembly listing.
- Rogue Byte: A byte placed in the code that is not actually part of the code and is there to throw off the disassembler. Usually placed after a jump instruction obfuscation technique therefore disassembly will continue at this byte, and the byte should be an opcode for a multi-byte instruction so the disassembly will be incorrect. 
- Structured Exception Handler: SEH is a feature of the x86 architecture and is intended to to provide a way for the program to handle error conditions intelligently. C++ and Ada translate naturally to SEH.
- SEH chain: A linked list of 8 byte data structures called EXCEPTION_REGISTRATION records.
- Unhandled Exception: An exception that was not handled by any of the functions in the SEH.
- TEB: Thread Environment Block.
- TIB: Thread Information Block.
- SafeSEH: Software DEP, Microsoft's Software Data Execution Prevention. Prevents the addition of custom exception handlers at runtime.




